package com.example.jvm.demo.thread;

/**
 * java 的内存模型与线程
 *
 * 实例字段、静态字段和构成数组对象的元素（存放在堆中，或者方法区）
 *
 * 不包括局部变量与方法参数（直接存在变量表中，是线程私有的不会出问题）
 *
 * 原子的、不可再分的操作：
 * lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
 * unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
 * read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
 * load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
 * use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
 * assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
 * store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
 * write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
 *
 * 基本操作时必须满足如下规则：
 * 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
 * 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
 * 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。
 * 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。
 * 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
 * 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
 * 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。
 * 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。
 *
 * long和double的非原子性协定:
 *      允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性(两次32位的操作)
 *      但现有都是原子操作
 *
 *
 * 对于volatile型变量的特殊规则：
 *  1.只能保证可见性，不能保证原子性
 *  2.禁止指令重排序优化
 *
 *  volatile使用场景：
 *  运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
 * 变量不需要与其他的状态变量共同参与不变约束。
 *
 *
 *
 *
 *
 *
 *  1.sleep()方法
 *
 * 在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。
 *
 * sleep()使当前线程进入阻塞状态，在指定时间内不会执行。
 *
 * 2.wait()方法
 *
 * 在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。
 *
 * 当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。
 *
 * 唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。
 *
 * waite()和notify()必须在synchronized函数或synchronized　block中进行调用。如果在non-synchronized函数或non-synchronized　block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。
 *
 * 3.yield方法
 *
 * 暂停当前正在执行的线程对象。
 *
 * yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。
 *
 * yield()只能使同优先级或更高优先级的线程有执行的机会。
 *
 * 4.join方法
 *
 * 等待该线程终止。
 *
 * 等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。
 * 5。notify/notifyAll
 *  notify是唤醒该对象相关的wait set的任意一个线程，notifyAll是唤醒相关的所有线程。
 *
 *
 *
 *
 *  原子性、可见性与有序性
 *
 *      1.原子性（Atomicity）  :
 *              1).我们大致可以认为基本数据类型的访问读写是具备原子性的
 *              2)lock和unlock操作（字节码开放）
 *              3）synchronized块之间的操作也具备原子性（monitorenter和monitorexit 字节码）
 *      2.可见性（Visibility）： 可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改
 *              1）volatile
 *              2）synchronized
 *              3）final
 *      3.有序性（Ordering）：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的
 *              1）volatile
 *              2）synchronized
 *
 *
 *  先行发生原则：
 *      程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面
 *              的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，
 *              因为要考虑分支、循环等结构。
 *      管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock
 *              操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。
 *      volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面
 *              对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。
 *      线程启动规则（Thread Start Rule）：Thread对象的start（）方法先行发生于此线程的每一个动作。
 *      线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的
 *              终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
 *      线程中断规则（Thread Interruption Rule）：对线程interrupt（）方法的调用先行发生于被
 *              中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted（）方法检测到是否有中断发生。
 *      对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发
 *              生于它的finalize（）方法的开始。
 *      传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就
 *              可以得出操作A先行发生于操作C的结论
 *
 *
 *   实现线程主要有3种方式：
 *          使用内核线程实现
 *          使用用户线程实现
 *          使用用户线程加轻量级进程混合实现
 *
 * 使用内核线程实现 :
 *      系统内核（Kernel，下称内核）
 *      内核线程（Kernel-Level Thread,KLT）
 *      调度器（Scheduler）
 *      轻量级进程（Light Weight Process,LWP）  种轻量级进程与内核线程之间1:1的关系
 *
 *      一个系统支持轻量级进程的数量是有限的
 *
 *  使用用户线程实现
 *     进程与用户线程之间1：N的关系称为一对多的线程模型
 *
 *   使用用户线程加轻量级进程混合实现
 *        用户线程与轻量级进程的数量比是不定的，即为N：M的关系
 *
 *   Sun JDK来说 :
 *          Windows版与Linux版都是使用一对一的线程模型实现的
 *    Solaris平台:
 *          同时支持一对一
 *           多对多
 *          虚拟机参数：-XX：+UseLWPSynchronization（默认值）和-XX：+UseBoundThreads来明确指定虚拟机使用哪种线程模型。
 *
 *
 *   Java线程调度:
 *        线程调度是指系统为线程分配处理器使用权的过程
 *        调度方式有两种:
 *              协同式线程调度（Cooperative Threads-Scheduling）
 *              抢占式线程调度（Preemptive ThreadsScheduling）(Java使用的线程调度方式)
 *
 *      线程状态：
 *              1.新建（New）：创建后尚未启动的线程处于这种状态。
 *              2.运行（Runable）：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间
 *              3.无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。
 *                      以下方法会让线程陷入无限期的等待状态：
 *                             ●没有设置Timeout参数的Object.wait（）方法。
 *                             ●没有设置Timeout参数的Thread.join（）方法
 *                             ●LockSupport.park（）方法
 *               4.限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。
 *                      以下方法会让线程进入限期等待状态：
 *                              ●Thread.sleep（）方法。
 *                              ●设置了Timeout参数的Object.wait（）方法。
 *                              ●设置了Timeout参数的Thread.join（）方法。
 *                              ●LockSupport.parkNanos（）方法。
 *                              ●LockSupport.parkUntil（）方法。
 *                5.阻塞（Blocked）：线程被阻塞了，（锁）
 *                      “阻塞状态”与“等待状态”的区别是：
 *                              “阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；
 *                                而“等待状态”则是在等待一段时间，或者唤醒动作的发生。
 *                               在程序等待进入同步区域的时候，线程将进入这种状态。
 *                         以下方法会让线程进入限期等待状态：
 *                                  synchronized
 *                                 Lock
 *                6.结束（Terminated）：已终止线程的线程状态，线程已经结束执行。
 *
 *  Java语言中的线程安全
 *
 *  Java语言中各种操作共享的数据分为以下5类
 *          不可变、（final）， 线程安全的
 *          绝对线程安全、
 *          相对线程安全、
 *          线程兼容
 *          线程对立 （死锁）
 *
 *  同步的类型：
 *      1.互斥同步
 *      2.非阻塞同步
 *      3.无同步方案
 *
 *    互斥同步
 *          相比synchronized,ReentrantLock增加了一些高级功能
 *               synchronized ：Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。
 *              CPU越多   synchronized 的性能差距越大
 *              主要有以下3项：
 *                    等待可中断：
 *                              正在等待的线程可以选择放弃等待，改为处理其他事情
 *                    可实现公平锁，
 *                               synchronized中的锁是非公平的
 *                               ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
 *                     以及锁可以绑定多个条件
 *
 *
 *
 *
 *     非阻塞同步：
 *          常用原子硬件指令集
 *                  测试并设置（Test-and-Set）。
 *                  获取并增加（Fetch-and-Increment）。
 *                  交换（Swap）。
 *                  比较并交换（Compare-and-Swap，下文称CAS）。  由sun.misc.Unsafe类里面的compareAndSwapInt（）和compareAndSwapLong（）等几个方法包装提供
 *                  加载链接/条件存储（Load-Linked/Store-Conditional，下文称LL/SC）
 *
 *     无同步方案
 *          可重入代码
 *
 *
 *
 *     Lock::::
 *      自旋：（Spinning）
 *              -XX：+UseSpinning(开启自旋锁 1.6 以后默认开启)
 *              -XX：PreBlockSpin来  （自旋次数 默认10 ）
 *      适应性自旋（Adaptive Spinning）
 *                  根据原来是否成功：确定是否使用自旋
 *                  使用自旋时，可能延长自旋次数
 *      锁消除Lock Elimination）
 *              虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除
 *                      逃逸分析的数据支持
 *      锁粗化（Lock Coarsening）
 *              会把加锁同步的范围扩展（粗化）到整个操作序列的外部（多次竞争锁导致，互斥）
 *      轻量级锁（Lightweight Locking）
 *              在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
 *      偏向锁（Biased Locking
 *          启用参数-XX：+UseBiasedLocking，这是JDK 1.6的默认值
 *
 *
 *
 *
 */

