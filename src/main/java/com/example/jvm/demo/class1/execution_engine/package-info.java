package com.example.jvm.demo.class1.execution_engine;
/**
 *  虚拟机字节码执行引擎
 *
 *
 *  invokestatic：调用静态方法。
 * invokespecial：调用实例构造器＜init＞方法、私有方法和父类方法。
 * invokevirtual：调用所有的虚方法。
 * invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。
 * invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方
 *          法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令
 *          的分派逻辑是由用户所设定的引导方法决定的。
 *
 *  方法得我分类
 *      非虚方法：有静态方法、私有方法、实例构造器、父类方法4类和final方法
 *      虚方法：非虚方法外
 *
 *  方法调用
 *         1.解析  （类加载阶段）
 *              一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成
 *
 *         2.分派  ：调用则可能是静态的也可能是动态的
 *                1）静态分配
 *                          所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。 class 直接确定不了（父类不确定子类是哪个有多个选择故多分派)
 *                          静态分派的典型应用是方法重载。
 *                2）动态分配
 *                          运行期根据实际类型确定方法执行版本的分派过程称为动态分派。 （运行时已经确定是哪个，单分派
 *                          重写（Override）有着很密切的关联
 *              1）单分派
 *                      只有一个宗量作为选择依据，
 *              2）多分派
 *
 * 方法匹配顺序
 *           重载：
 *                0.重写
 *                1.基本类型 自动升级 按照byte-＞short-＞char-＞int-＞long-＞float-＞double的顺序转型进行匹配
 *                2. 基本类型找不到值 自动装箱该类，但不会转型
 *                3.迭代找父类 （如果在同一级父类出现两个，编译不通过）
 *                4．可见变长参数 （参考 1,2,3顺序, 123，满足的多参只能是一个）
 *            重写（Override）
 *               1.描述符和简单名称都相符的方法
 *               2.访问权限校验
 *               3.递归找父类（执行1。2 步）
 *
 *
 * 指令集：
 *    基于栈的指令集（JVM）
 *              有点：可移植
 *                     代码相对更加紧凑
 *                     编译器实现更加简单
 *               缺点：相对寄存器指令集慢
 *                              操作内存（内存速度相对寄存器慢）
 *                              同等功能指令多
 *
 *
 *    基于寄存器的指令集
 *              缺点：只能在相同指令集中运行
 */

