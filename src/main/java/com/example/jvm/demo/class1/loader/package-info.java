package com.example.jvm.demo.class1.loader;
/**
 *
 * 类加载器
 *
 * 1.类加载时，不一定是本地的一个class 文件， 也可以其他形式的到的遗传二进制字节流
 *   class文件是以字节做操作的，操作符等都是1字节，
 *   想Applet、jsp、OSGi 都是运行时加载的字符流
 *
 *   类加载流程： （从加载到内存，到卸载出内存为止）7个阶段
 *          1、加载（Loading）
 *              1）通过一个类的全限定名来获取定义此类的二进制字节流。
 *              2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
 *              3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
 *          2、验证（Linking .Verification）  ---所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间
 *               1)文件格式验证     (验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理  基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储)
 *                          a.是否以魔数0xCAFEBABE开头。
 *                          b.主、次版本号是否在当前虚拟机处理范围之内。
 *                          c.常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。
 *                          d.指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
 *                          e.CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。
 *                          f.Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。
 *                          .......
 *               2)元数据验证    (基于方法区的存储结构进行,对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范的要求)
 *                          a.这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。
 *                          b.这个类的父类是否继承了不允许被继承的类（被final修饰的类）
 *                          c.如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
 *                          d.类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）
 *                          .........
 *               3)字节码验证        (主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 方法体  StackMapTable属性验证)
 *                          a.保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。
 *                          b.保证跳转指令不会跳转到方法体以外的字节码指令上。
 *                          c.保证方法体中的类型转换是有效的，
 *                          .........
 *               4)符号引用验证
 *                          a.符号引用中通过字符串描述的全限定名是否能找到对应的类。
 *                          b.在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
 *                          c.符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问
 *                          .........
 *          3、准备（Linking .Preparation）----准备阶段是方法区中 正式为类变量(被static修饰的变量)分配内存并设置类变量初始值
 *                         a.“通常情况”下初始值是零值
 *                         b.：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为
 *                                  ConstantValue属性所指定的值
 *          4、解析（Linking .Resolution） ---- 虚拟机将常量池内的符号引用替换为直接引用
 *                         a.未规定解析阶段发生的具体时间，只要求了在执行anewarray、 checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfi
 *
 *                          类或接口的解析：
 *                                              1）不是数组时用代码所处类加载器去加载要加载的类
 *                                              2）如果C是一个数组类型  地柜到1）
 *
 *                          字段解析：
 *                                              1）字段在本身，直接返回直接引用
 *                                              2）本身不存在，按顺序查找接口，存在直接返回直接引用（继承顺序，同事两个接口不知道会有问题么）
 *                                              3） 在1、2中 未找到 按继承顺序找其父类，存在直接返回直接引用（除父类为java.lang.Object）
 *                                              4）查询访问权限
 *                                   总结：只要不在统一层的继承中存在相同的字段即可，该字段即可使用，以就近原则找到字段，然后判断该字段权限，就算权限不过也不会继续找
 *
 *                           类方法解析：
 *                                              1）方法不能使接口的方法 --如果在类方法表中发现class_index中索引的C是个接口，就直接抛出java.lang.IncompatibleClassChangeError异常
 *                                              2）在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用
 *                                              3）在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法
 *                                              4）在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法。如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常
 *                                              5）宣告方法查找失败，抛出java.lang.NoSuchMethodError
 *                                              6）方法进行权限验证
 *                            接口方法解析：
 *                                              1）与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常
 *                                              2）在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用
 *                                              3）在接口C的父接口中递归查找，直到java.lang.Object类（
 *                                              4）宣告方法查找失败，抛出java.lang.NoSuchMethodError异常
 *
 *
 *          5、初始化（Initialization）  --初始化类变量和其他资源  --初始化阶段是执行类构造器＜clinit＞（）方法的过程
 *                          clinit＞（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}块）中的语句合并产生的，
 *                              编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问
 *
 *          6、使用（Using）
 *          7、卸载（Unloading）
 *
 *  必须立即初始化的5种情况：
 *          1）遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化
 *                      (即new，或者调用静态变量（除final修饰的），静态方法)
 *          2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
 *          3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
 *          4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main() 方法的那个类），虚拟机会先初始化这个主类。
 *          5）当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
 *
 *  被动引用--不初始化样例：
 *      1.通过子类引用父类的静态字段，不会导致子类初始化
 *      2.通过数组定义来引用类，不会触发此类的初始化
 *
 *  类加载-加载
 *    数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（下面简称为C）创建过程就遵循以下规则：
 *
 *
 *  引用：
 *      符号引用（Symbolic References）引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可 引用的目标并不一定已经加载到内存中
 *      直接引用（Direct References）  直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。那引用的目标必定已经在内存中存在。
 *
 *
 *   类加载器：  通过一个类的全限定名来获取描述此类的二进制字节流  先判断类加载器是否相同
 *          比较两个类是否“相等”
 *                      2.类的Class对象的equals（）方法
 *                      3.isAssignableFrom（）方法
 *                      4.isInstance（）方法的返回结果
 *                      5.instanceof关键字做对象所属关系判定等情况
 *
 *
 *  类加载器分类：
 *             1.启动类加载器（Bootstrap ClassLoader）
 *                      将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中
 *             2.扩展类加载器（Extension ClassLoader）
 *                      负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库   (加载器由sun.misc.Launcher$ExtClassLoader实现)
 *
 *                      加载用户类路径（ClassPath）上所指定的类库
 *
 *
 *    双亲委派模型：
 *               1.启动类加载器（Bootstrap ClassLoader）
 *               2.扩展类加载器（Extension ClassLoader）
 *               3.应用程序类加载器（Application ClassLoader）
 *               4.自定义类加载器User ClassLoader
 *    OSGi ： 自定义依赖还是发布什么 不是固定关系
 *              1）将以java.*开头的类委派给父类加载器加载。
 *              2）否则，将委派列表名单内的类委派给父类加载器加载。
 *              3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。
 *              4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。
 *              5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载
 *              6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。
 *              7）否则，类查找失败
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

